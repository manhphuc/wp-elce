"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @class WebpackBuildNotifierPlugin
 * @extends Object
 * A Webpack plugin that generates OS notifications for build steps using node-notifier.
 */
var path_1 = __importDefault(require("path"));
var process_1 = __importDefault(require("process"));
var os_1 = __importDefault(require("os"));
var node_notifier_1 = __importDefault(require("node-notifier"));
var strip_ansi_1 = __importDefault(require("strip-ansi"));
var child_process_1 = require("child_process");
var types_1 = require("./types");
var DEFAULT_ICON_PATH = path_1.default.resolve(__dirname, 'icons');
var WebpackBuildNotifierPlugin = /** @class */ (function () {
    function WebpackBuildNotifierPlugin(cfg) {
        var _this = this;
        var _a, _b, _c, _d;
        this.appName = undefined;
        this.buildSuccessful = false;
        this.hasRun = false;
        // config options
        this.title = 'Webpack Build';
        this.sound = 'Submarine';
        this.suppressSuccess = false;
        this.suppressWarning = false;
        this.suppressCompileStart = true;
        this.activateTerminalOnError = false;
        this.showDuration = false;
        this.successIcon = path_1.default.join(DEFAULT_ICON_PATH, 'success.png');
        this.warningIcon = path_1.default.join(DEFAULT_ICON_PATH, 'warning.png');
        this.failureIcon = path_1.default.join(DEFAULT_ICON_PATH, 'failure.png');
        this.compileIcon = path_1.default.join(DEFAULT_ICON_PATH, 'compile.png');
        this.onClick = function () { return _this.activateTerminalWindow; };
        this.activateTerminalWindow = function () {
            if (process_1.default.platform === 'darwin') {
                // TODO: is there a way to translate $TERM_PROGRAM into the application name
                // to make this more flexible?
                child_process_1.exec('TERM="$TERM_PROGRAM"; ' +
                    '[[ "$TERM" == "Apple_Terminal" ]] && TERM="Terminal"; ' +
                    '[[ "$TERM" == "vscode" ]] && TERM="Visual Studio Code"; ' +
                    'osascript -e "tell application \\"$TERM\\" to activate"');
            }
            else if (process_1.default.platform === 'win32') {
                // TODO: Windows platform
            }
        };
        // formats the error/warning message
        this.formatMessage = function (error, filepath, status, errorCount) {
            var message = undefined;
            if (_this.messageFormatter) {
                message = _this.messageFormatter(error, filepath, status, errorCount);
            }
            else {
                message = (error.message || error.details);
                if (message && error.module && error.module.resource) {
                    message = "" + filepath + os_1.default.EOL + message.replace(error.module.resource, '');
                }
            }
            if (message === undefined) {
                return 'Unknown';
            }
            else if (typeof message === 'string') {
                return message.substr(0, 256); // limit message length to 256 characters, fixes #20
            }
            else {
                throw "Invalid message type '" + typeof message + "'; messageFormatter must return a string.";
            }
        };
        this.onCompilationDone = function (results) {
            var _a, _b, _c;
            var notify = false;
            var title = _this.title + " - ";
            var msg = (_b = (_a = _this.formatSuccess) === null || _a === void 0 ? void 0 : _a.call(_this)) !== null && _b !== void 0 ? _b : 'Build successful!';
            var icon = _this.successIcon;
            var sound = _this.successSound;
            var compilationStatus = types_1.CompilationStatus.SUCCESS;
            if (results.hasErrors()) {
                var error = _this.getFirstWarningOrError(results.compilation, 'errors');
                var errorFilePath = error.module && error.module.resource ? error.module.resource : '';
                notify = true;
                compilationStatus = types_1.CompilationStatus.ERROR;
                title += 'Error';
                msg = _this.formatMessage(error, errorFilePath, compilationStatus, _this.getWarningOrErrorCount(results.compilation, 'errors'));
                icon = _this.failureIcon;
                sound = _this.failureSound;
                _this.buildSuccessful = false;
            }
            else if (!_this.suppressWarning && results.hasWarnings()) {
                var warning = _this.getFirstWarningOrError(results.compilation, 'warnings');
                var warningFilePath = warning.module && warning.module.resource ? warning.module.resource : '';
                notify = true;
                compilationStatus = types_1.CompilationStatus.WARNING;
                title += 'Warning';
                msg = _this.formatMessage(warning, warningFilePath, compilationStatus, _this.getWarningOrErrorCount(results.compilation, 'warnings'));
                icon = _this.warningIcon;
                sound = _this.warningSound;
                _this.buildSuccessful = false;
            }
            else {
                title += 'Success';
                if (_this.showDuration) {
                    msg += " [" + (results.endTime - results.startTime) + " ms]";
                }
                /* istanbul ignore else */
                if (_this.suppressSuccess === 'always' || (_this.suppressSuccess === 'initial' && !_this.hasRun)) {
                    notify = false;
                }
                else if (_this.suppressSuccess === false || !_this.buildSuccessful) {
                    notify = true; // previous build failed, let's show a notification even if success notifications are suppressed
                }
                _this.buildSuccessful = true;
            }
            var notifyOptions = (_c = (typeof _this.notifyOptions === 'function'
                ? _this.notifyOptions(compilationStatus)
                : _this.notifyOptions)) !== null && _c !== void 0 ? _c : {};
            /* istanbul ignore else */
            if (notify) {
                node_notifier_1.default.notify(Object.assign(notifyOptions, {
                    title: title,
                    sound: sound,
                    icon: icon,
                    appName: _this.appName,
                    message: strip_ansi_1.default(msg),
                    contentImage: _this.logo,
                    wait: !_this.buildSuccessful
                }));
                /* istanbul ignore else */
                if (_this.onComplete) {
                    _this.onComplete(results.compilation, compilationStatus);
                }
            }
            /* istanbul ignore else */
            if (_this.activateTerminalOnError && !_this.buildSuccessful) {
                _this.activateTerminalWindow();
            }
            _this.hasRun = true;
        };
        this.onCompilationWatchRun = function (compiler, callback) {
            node_notifier_1.default.notify({
                appName: _this.appName,
                title: _this.title,
                message: 'Compilation started...',
                contentImage: _this.logo,
                icon: _this.compileIcon,
                sound: _this.compilationSound
            });
            /* istanbul ignore else */
            if (_this.onCompileStart) {
                _this.onCompileStart(compiler);
            }
            callback();
        };
        this.registerSnoreToast = function () {
            // ensure the SnoreToast appId is registered, which is needed for Windows Toast notifications
            // this is necessary in Windows 8 and above, (Windows 10 post build 1709), where all notifications must be generated
            // by a valid application.
            // see: https://github.com/KDE/snoretoast, https://github.com/RoccoC/webpack-build-notifier/issues/20
            /* istanbul ignore else */
            if (process_1.default.platform === 'win32') {
                var versionParts = os_1.default.release().split('.');
                var winVer = +(versionParts[0] + "." + versionParts[1]);
                /* istanbul ignore else */
                if (winVer >= 6.2) {
                    // Windows version >= 8
                    var snoreToast = path_1.default.join(require.resolve('node-notifier'), '../vendor/snoreToast', "snoretoast-" + (process_1.default.arch === 'x64' ? 'x64' : 'x86') + ".exe");
                    try {
                        child_process_1.execFileSync(snoreToast, [
                            '-appID',
                            'Snore.DesktopToasts',
                            '-install',
                            'SnoreToast.lnk',
                            snoreToast,
                            'Snore.DesktopToasts'
                        ]);
                        _this.appName = 'Snore.DesktopToasts';
                    }
                    catch (e) {
                        console.error('An error occurred while attempting to install the SnoreToast AppID!', e);
                    }
                }
            }
        };
        this.getFirstWarningOrError = function (compilation, type) {
            /* istanbul ignore else */
            if (compilation.children && compilation.children.length) {
                for (var i = 0; i < compilation.children.length; i++) {
                    var warningsOrErrors = compilation.children[i][type];
                    /* istanbul ignore else */
                    if (warningsOrErrors && warningsOrErrors[0]) {
                        return warningsOrErrors[0];
                    }
                }
            }
            return compilation[type][0];
        };
        this.getWarningOrErrorCount = function (compilation, type) {
            /* istanbul ignore else */
            if (compilation.children && compilation.children.length) {
                var count = compilation.children.reduce(function (acc, child) {
                    var currentCount = acc;
                    var warningsOrErrors = child[type];
                    /* istanbul ignore else */
                    if (warningsOrErrors) {
                        currentCount += warningsOrErrors.length;
                    }
                    return currentCount;
                }, 0);
                /* istanbul ignore else */
                if (count > 0) {
                    return count;
                }
            }
            return compilation[type].length;
        };
        Object.assign(this, cfg);
        if (this.sound) {
            this.successSound = (_a = this.successSound) !== null && _a !== void 0 ? _a : this.sound;
            this.warningSound = (_b = this.warningSound) !== null && _b !== void 0 ? _b : this.sound;
            this.failureSound = (_c = this.failureSound) !== null && _c !== void 0 ? _c : this.sound;
            this.compilationSound = (_d = this.compilationSound) !== null && _d !== void 0 ? _d : this.sound;
        }
        this.registerSnoreToast();
        node_notifier_1.default.on('click', this.onClick);
        /* istanbul ignore else */
        if (this.onTimeout) {
            node_notifier_1.default.on('timeout', this.onTimeout);
        }
    }
    WebpackBuildNotifierPlugin.prototype.apply = function (compiler) {
        if (compiler.hooks && compiler.hooks.watchRun && compiler.hooks.done) {
            // for webpack >= 4
            /* istanbul ignore else */
            if (!this.suppressCompileStart) {
                compiler.hooks.watchRun.tapAsync('webpack-build-notifier', this.onCompilationWatchRun);
            }
            compiler.hooks.done.tap('webpack-build-notifier', this.onCompilationDone);
        }
        else {
            // for webpack < 4
            /* istanbul ignore else */
            if (!this.suppressCompileStart) {
                compiler.plugin('watch-run', this.onCompilationWatchRun);
            }
            compiler.plugin('done', this.onCompilationDone);
        }
    };
    return WebpackBuildNotifierPlugin;
}());
exports.default = WebpackBuildNotifierPlugin;
module.exports = WebpackBuildNotifierPlugin;
